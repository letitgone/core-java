# Core Java(Volume 1_Fundamentals)
    core java notes
## V1_Chapter 7: 异常，断言和日志
1.当程序发生错误时，应该做到以下几点：   
1）向用户通告错误；   
2）保存所有的工作结果；   
3）允许用户以妥善的形式退出程序。
### 7.1 处理错误
1.在Java程序设计语言中，异常对象都是派生于Throwable类的一个实例。   
2.Java异常层次结构简化示意图：
![Image text](src/main/resources/image/ExceptionDiagram.jpeg)
3.所有的异常都是由Throwable继承而来。   
4.Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误，应用程序不应该抛出这种类型的对象，如果出现了这样的内
部错误，除了通告给用户，并尽力使程序安全地终止之外，再也无能为力，这种情况很少出现。   
5.Exception分为两个分支：一个分支派生于RuntimeException，另一个分支包含其他异常，划分两个分支的规则是：由程序错误
导致的异常属于RuntimeException，而程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常。   
派生于RuntimeException的异常包含下面几种情况：   
1）错误的类型转换；   
2）数组访问越界；   
3）访问null指针。   
不是派生于RuntimeException的异常包含：  
1）试图在文件尾部后面读取数据；   
2）试图打开一个不存在的文件；   
3）试图根据给定的字符串查找Class对象，而这个字符串表示的类不存在。   
6.Java语言规范将派生于Error类或者RuntimeException类的所有异常称为非受查（unchecked）异常，所有其他的异常称为受
查（checked）异常，编译器将检查是否为所有的受查异常提供了异常处理器。   
7.以下四种情况需要抛出异常，使用throws子句声明：   
1）调用一个抛出受查异常的方法，例如，FileInputStream构造器。   
2）程序运行过程中发现错误，并且利用throw语句抛出一个受查异常。   
3）程序出现错误，例如，a[-1]=0会抛出一个ArrayIndexOutOfBoundsException这样的非受查异常。   
4）Java虚拟机和运行时库出现的内部错误。   
8.一个方法必须声明所有可能抛出的受查异常，而非受查异常要么不可控制（Error），要么就应该避免发生（RuntimeException），
如果方法没有声明所有可能发生的受查异常，编译器就会发出一个错误信息。   
9.如果在子类中覆盖了超类的一个方法，子类方法中声明的受查异常不能比超类方法中声明的异常更通用（也就是说，子类方法中可
以抛出更特定的异常，或者根本不抛出任何异常），如果超类方法没有抛出任何受查异常，子类也不能抛出任何受查异常。
### 7.2捕获异常
1.通常应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续进行传递，如果想传递一个异常，就必须在方法的首
部添加一个throws说明符，以便告知调用者这个方法可能会抛出异常。   
2.捕获多个异常时，异常变量隐含为final变量。   
3.强烈建议解耦合，使用如下方式：
```
try {
    try {
        System.out.println("hello");
    } finally {
        System.out.println("always");
    }
} catch (Exception e) {
    e.printStackTrace();
}
```
### 7.3 使用异常机制的技巧
1.异常机制技巧：   
1）异常处理不能代替简单测试，只有在异常情况下使用异常机制；   
2）不要过分的细化异常，将正常处理与异常分开；   
3）利用异常层次结构，不要只抛出RuntimeException异常，应该寻找更加适当的子类或创建自己的异常类；   
4）不要压制异常；   
5）在检测错误时，"苛刻"要比放任更好；   
6）不要羞于传递异常，让高层次的方法通知用户发生了错误，或者放弃不成功的命令更加适宜。
### 7.4 使用断言
1.断言机制允许在测试期间向代码中插入一些检查语句，当代码发布时，这些插入的检测语句将会自动地移走，Java语言引入了关键
字，这个关键字有两种形式：assert condition；  or  assert condition : expression;。这两种形式都会对条件进行检
查，如果结果为false，则抛出一个AssertionError异常，在第二种形式中，表达式将被传入AssertionError的构造器，并转换
成一个消息字符串。   
2.表达式部分唯一的目的是产生一个消息字符串,AssertionError对象并不存储表达式的值。例如：assert x >= 0; 或者将x的
实际值传递给AssertionError对象，从而可以在后面显示出来：assert x >= 0 : x; 如果希望打印表达式：
assert x >= 0 : "x >= 0";   
3.在默认情况下，断言被禁用，在启用或禁用断言时不必重新编译程序，启用或禁用断言是类加载器的功能，当断言被禁用时，类加
载器将跳过断言代码，因此，不会降低程序运行速度。   
4.在Java语言中，给出了3中处理系统错误的机制：1）抛出一个异常；2）日志；3）使用断言。什么时候应该使用断言呢？请记住
以下几点：1）断言失败是致命的，不可恢复的错误；2）断言检查只用于开发测试阶段。   
### 7.5 记录日志
1.未被任何变量引用的日志记录器可能会被垃圾回收，为了防止这种情况发生，要像上面的例子一样，用一个静态变量存储日志记录
器的一个引用：
```$xslt
private static final Logger logger = Logger.getLogger("com.mycompany.myapp");
```
### 7.6 调试技巧
