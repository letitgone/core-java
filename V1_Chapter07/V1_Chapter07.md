# Core Java(Volume 1_Fundamentals)
    core java notes
## V1_Chapter 7: 异常，断言和日志
1.当程序发生错误时，应该做到以下几点：   
1）向用户通告错误；   
2）保存所有的工作结果；   
3）允许用户以妥善的形式退出程序。
### 7.1 处理错误
1.在Java程序设计语言中，异常对象都是派生于Throwable类的一个实例。   
2.Java异常层次结构简化示意图：
![Image text](src/main/resources/image/ExceptionDiagram.jpeg)
3.所有的异常都是由Throwable继承而来。   
4.Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误，应用程序不应该抛出这种类型的对象，如果出现了这样的内
部错误，除了通告给用户，并尽力使程序安全地终止之外，再也无能为力，这种情况很少出现。   
5.Exception分为两个分支：一个分支派生于RuntimeException，另一个分支包含其他异常，划分两个分支的规则是：由程序错误
导致的异常属于RuntimeException，而程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常。   
派生于RuntimeException的异常包含下面几种情况：   
1）错误的类型转换；   
2）数组访问越界；   
3）访问null指针。   
不是派生于RuntimeException的异常包含：  
1）试图在文件尾部后面读取数据；   
2）试图打开一个不存在的文件；   
3）试图根据给定的字符串查找Class对象，而这个字符串表示的类不存在。   
6.Java语言规范将派生于Error类或者RuntimeException类的所有异常称为非受查（unchecked）异常，所有其他的异常称为受
查（checked）异常，编译器将检查是否为所有的受查异常提供了异常处理器。   
7.以下四种情况需要抛出异常，使用throws子句声明：   
1）调用一个抛出受查异常的方法，例如，FileInputStream构造器。   
2）程序运行过程中发现错误，并且利用throw语句抛出一个受查异常。   
3）程序出现错误，例如，a[-1]=0会抛出一个ArrayIndexOutOfBoundsException这样的非受查异常。   
4）Java虚拟机和运行时库出现的内部错误。   
8.一个方法必须声明所有可能抛出的受查异常，而非受查异常要么不可控制（Error），要么就应该避免发生（RuntimeException），
如果方法没有声明所有可能发生的受查异常，编译器就会发出一个错误信息。   
9.如果在子类中覆盖了超类的一个方法，子类方法中声明的受查异常不能比超类方法中声明的异常更通用（也就是说，子类方法中可
以抛出更特定的异常，或者根本不抛出任何异常），如果超类方法没有抛出任何受查异常，子类也不能抛出任何受查异常。
### 7.2捕获异常
1.通常应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续进行传递，如果想传递一个异常，就必须在方法的首
部添加一个throws说明符，以便告知调用者这个方法可能会抛出异常。   
2.捕获多个异常时，异常变量隐含为final变量。   
3.强烈建议解耦合，使用如下方式：
```
try {
    try {
        System.out.println("hello");
    } finally {
        System.out.println("always");
    }
} catch (Exception e) {
    e.printStackTrace();
}
```
### 7.3 使用异常机制的技巧
1.异常机制技巧：   
1）异常处理不能代替简单测试，只有在异常情况下使用异常机制；   
2）不要过分的细化异常，将正常处理与异常分开；   
3）利用异常层次结构，不要只抛出RuntimeException异常，应该寻找更加适当的子类或创建自己的异常类；   
4）不要压制异常；   
5）在检测错误时，"苛刻"要比放任更好；   
6）不要羞于传递异常，让高层次的方法通知用户发生了错误，或者放弃不成功的命令更加适宜。
### 7.4 使用断言
1.断言机制允许在测试期间向代码中插入一些检查语句，当代码发布时，这些插入的检测语句将会自动地移走，Java语言引入了关键字
