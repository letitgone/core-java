# Core Java(Volume 1_Fundamentals)
    core java notes
## V1_Chapter 9 集合
### 9.1 Java集合框架
1.当需要收集对象，并按照"先进先出"的规则检索对象时就应该使用队列。   
2.队列通常有两种实现方式：一种是使用循环数组，另一种是使用链表。循环数组要比链表效率更高，因此多数人优先使用循环数组，
然而，通常这样做也需要付出一定的代价，循环数组是一个有界集合，即容量有限，如果程序中要收集的对象数量没有上限，就最好
使用链表来实现。   
3.链表尽管也是有序的，但是随机访问很慢，所以最好使用迭代器来遍历，JavaSE 1.4引入了一个标记借口RandomAccess，可以
用来测试一个特定的集合是否支持高效的随机访问。   
### 9.2 具体的集合
1.尽管数组在连续的存储位置上存放对象引用，但是链表却将每个对象存放在独立的结点中，每个结点还存放着序列中下一个结点的
引用，在Java程序设计语言中，所有链表实际上都是双向链接的，即每个结点还存放着指向前驱结点的引用，从链表中删除一个元素
是一个很轻松的操作，即需要更新被删除元素附近的链接。   
3.ArrayList不是线程安全的。   
4.TreeSet排序是用树结构完成的，即红黑树，每次将一个元素添加到树中，都被放置在正确的排序位置上，因此，迭代器总是以排
序好的顺序访问每个元素。   
5.队列可以让人们有效地在尾部添加一个元素，在头部删除一个元素，有两个端头的队列，即双端队列，可以让人们有效地在头部和
尾部同时添加或删除元素，不支持在队列中间添加元素，在JavaSE6中引入了Deque接口，并由ArrayDeque和LinkedList来实现，
这两个类都提供了双端队列，并且在必要时可以增加队列的长度。   
6.priority queue优先级队列中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索，也就是说，无论何时调用remove
方法，总会获得当前优先级队列中最小的元素，优先级队列使用了一个优雅且高效的数据结构，成为堆（heap），堆是一个可以自我
调整的二叉树，对树执行添加删除操作，可以让最小的元素移动到跟，而不必花费时间对元素进行排序。优先级队列典型示例是任务
调度，每一个任务都有一个优先级，任务以随机顺序添加到队列中，每当启动一个新的任务时，都将优先级高的任务从队列中删除（
由于习惯上将1设置为最高优先级，所以会将最小的元素删除。   
### 9.3 映射
1.用lambda表达式遍历map:
```
staff.forEach((k, v) -> System.out.println("key=" + k + ", value=" + v));
```
### 9.4 视图与包装器
### 9.5 算法
1.Java实现二分查找用Collections.binarySearch(c, element)，集合必须是排好序的，只能使用ArrayList进行随机访问，
如果提供linkedList则没有意义，它将自动变为线性查找。   
2.Java SE8增加了默认方法Collection.removeIf和List.replaceAll方法。   
### 9.6 遗留的集合
