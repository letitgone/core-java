# Core Java(Volume 1_Fundamentals)
    core java notes
## V1_Chapter 5: 继承
### 5.1 类，超类和子类
1.super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个只是编译器调用超类方法的特殊关键字。   
2.使用super调用构造器的语句必须是子类构造器的第一条语句。   
3.如果子类的构造器没有显式的调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器，如果超类没有不带参数的构造
器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则编译器报错。   
4.this关键字的两个用途，一是，引用隐式参数，而是，调用该类其他的构造器，super关键字的两个作用，一是，调用超类的方法，
而是，调用超类的构造器。调用构造器只能作为另一个构造器的第一条语句出现，构造参数既可以传递给本类的其他构造器，也可以
传递给超类的构造器。   
5.一个对象变量可以指示多种实际类型的现象称为多态(polymorphism)。在运行时能够自动地选择调用哪个方法的现象称为动态绑
定(dynamic binding)。   
6.final:   
Java中的final关键字修饰的项不可更改。具体来说就是:   
1)final class不能被继承(不允许扩展的类)。   
2)final 变量的值不能更改（构造对象以后就不允许修改它们的值了，如果将一个类声明为final，只有其中的方法自动地成为
final，而不包括域）。   
3)final 方法不能被覆写（子类不能覆盖这个方法，final类中所有的方法自动地成为final方法）。   
对于引用类型的变量，final的意思是声明变量时它指向哪个对象，它就要一直指向那个对象，那个对象变化与否都没关系。   
7.进行类型转换的唯一原因是：在暂时忽略对象的实际类型之后，使用对象的全部功能。   
8.只能在继承层次内进行类型转换，在将超类转换成子类之前，应该使用instanceof进行检查。   
9.抽象类：   
1）包含一个或多个抽象方法的类本身必须被声明为抽象的。   
2）除了抽象方法之外，抽象类还可以包含具体数据和具体方法。   
3）抽象方法没有方法体，也不能写{}。
4）类即使不包含抽象方法，也可以将类声明为抽象类。   
5）抽象类不能被实例话，但可以创建具体子类的对象。      
10.扩展抽象类可以有两种选择：   
1）在抽象类中定义部分抽象类方法或者不定义抽象类方法，这样就必须将子类也标记为抽象类。   
2）定义全部的抽象方法，这样一来，子类就不是抽象的了。   
11.可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象：Person p = new Student();   
### 5.2 Object:所有类的超类
1.所有的数组类型，不管是对象数组还是基本类型数组都扩展了Object类。   
2.Java语言规范要求equals()方法具有如下特性：   
1）自反性：对于任何非空引用x，x.equals(x)应该返回true。   
2）对称性：对于任何引用x和y，并且仅当y.equals(x)返回true，x.equals(y)也应该返回true。   
3）传递性：对于任何引用x，y和z，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true。   
4）一致性：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果。   
5）对于任何非空引用x，x.equals(null)应该返回false。   
3.hashCode方法：   
1）散列码（hash code）是由对象导出的一个整型数值（也可以是负数），散列码是没有规律的，如果x和y是两个不同的对象，x.hashCode()与
y.hashCode()基本上不会相同。   
2）String类使用下面算法计算散列码：   
```
int hash = 0;
for(int i = 0; i < length(); i++){
    hash = 31 * hash + charAt(i);
}
```
3）由于hashCode()定义在Object类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址：   
```
String s = "Ok";
StringBuilder sb = new StringBuilder(s);
System.out.println(s.hashCode() + " " + sb.hashCode());
String t = new String("Ok");
StringBuilder tb = new StringBuilder(t);
System.out.println(t.hashCode() + " " + tb.hashCode());
```
字符串s和t拥有相同的散列码，这是因为字符串的散列码是由内容导出的，而字符串缓冲sb和tb却有着不同的散列码，这是因为在
StringBuilder类中没有定义hashCode()方法，它的散列码是由Object类的默认hashCode()方法导出的对象存储地址。如果重新
定义equals方法，即必须重新定义hashCode()方法，以便用户可以将对象插入到散列表中。   
4）equals()和hashCode()的定义必须一致，如果x.equals(y)返回true，那么x.hashCode()就必须与y.hashCode()具有相
同的值。    
### 5.3 泛型数组列表
1.Java中，允许在运行时确定数组的大小。   
2.Java SE7中，可以省去右边的类型参数：   
```
List<Employee> list = new ArrayList<Employee>(100);
List<Employee> list = new ArrayList<>();
```
3.如果调用add且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。   
4.如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用ensureCapacity()方法，这个方法调用将分配
一个包含100个对象的内部数组，然后调用100次add，而不用重新分配空间，另外，还可以把初始容量传递给ArrayList构造器。   
5.如果为数组分配100个元素的存储空间，数组就有100个空位置可以使用，而容量为100个元素的数组列表只是拥有保存100个元素
的潜力（实际上，重新分配空间的话，将会超过100），但是在最初，甚至完成初始化构造之后，数组列表根本就不包含任何元素。   
6.一旦能够确定数组列表的大小不再发生变化，就可以调用trimToSize()方法，增额方法将存储区域的大小调整为当前元素数量所
需要的存储数目，垃圾回收器将回收多余的存储空间，一旦整理了数组列表的大小，添加新元素就需要花时间再次移动存储块，所以
应该在确认不会添加任何元素时，再调用trimToSize()方法。   
7.为了插入一个新元素，位于n之后的所有元素都要向后移动一个位置，如果新插入元素后，数组列表的大小超过了容量，数组列表
就会被重新分配存储空间。   
### 5.4 对象包装器与自动装箱
1.Integer,Long,Float,Double,Short,Byte类派生于公共的超类Number，对象包装器类是不可变的，即一旦构造了包装器类，
就不允许更改包装在其中的值，同时，对象包装器类还是final，因此不允许定义它们的子类。   
2.装箱与拆箱是编译器认可的，而不是虚拟机，编译器在生成类的字节码时，插入必要的方法调用，虚拟机只是执行这些字节码。
### 5.5 参数数量可变的方法
### 5.6 枚举类
1.在比较两个枚举类型时，永远不需要调用equals，而直接使用"=="就可以了。   
2.每个枚举类型都有一个静态的values方法，它将返回一个包含全部枚举值的数组。   
### 5.7 反射
1.能够分析类能力的程序成为反射。反射机制可以用来：1）在运行时分析类的能力；2）在运行时查看对象；3）实现通用的数组操
作代码；4）利用Method对象。   
2.在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识，这个信息跟踪着每个对象所属的类，虚拟
机利用运行时类型信息选择相应的方法执行。保存这些信息的类被称为Class。   
3.一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类，例如：int不是类，但是int.class是一个Class类型
的对象。Class类实际上是一个泛型类，它将已经抽象的概念更加复杂化了，在大多数实际问题中，可以忽略类型参数，而使用原始
的Class类。   
4.获取Class类对象的三种方法：1）new Employee().getClass()；2）Employee.class；3）Class.forName(calssName)。   
5.虚拟机为每个类型管理一个Class对象。因此，可以利用==运算符实现两个类对象比较的操作。   
6.newInstance方法调用默认的构造器（没有参数的构造器）初始化创建的对象，如果这个类没有默认的构造器，就会抛出一个异常。   
7.Throwable是Exception类的超类。   
8.getDeclareFields，方法将返回类中声明的全部域，其中包括私有的和受保护成员，但是不包括超类的成员。      
### 5.8 继承的设计技巧
1.将公共操作和域放在超类。   
2.不要使用受保护的域。   
3.使用继承实现"is-a"关系。   
4.除非所有继承的方法都有意义，否则不要使用继承。   
5.在覆盖方法时，不要改变预期的行为。   
6.使用多态，而非类型信息。   
7.不要过多地使用反射。
